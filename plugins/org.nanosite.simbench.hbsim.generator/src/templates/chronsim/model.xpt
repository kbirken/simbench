«IMPORT hbsim»
«EXTENSION templates::helpers»
«EXTENSION templates::expressions»
«EXTENSION templates::hbsim::Extensions»
«EXTENSION templates::chronsim::chronsim»


«REM»**********************************************************************«ENDREM»

«DEFINE Transform(String targetPath, String basePath, String genPath) FOR Model»
  «EXPAND EntitiesFile FOR this»
  «EXPAND PeripheralsFile FOR this»
  «EXPAND ModelHeaderFile(basePath) FOR this»
  «EXPAND ResourceFile(getAllFunctionBlocks(), this) FOREACH getAllResources()»
  «EXPAND SingleCPUFile(basePath, this) FOREACH getAllCPUs()»

  «FILE "model_config.h"»
	«FOREACH getAllFunctionBlocks().getReachableBehaviours(this).plan.step.getPreconditions(main.config) AS p-»
		«IF p.opt-»
		#define «EXPAND ConfigId(main.config) FOR p-» 1
		«ENDIF-»
	«ENDFOREACH-»
  «ENDFILE»

  «EXPAND templates::chronsim::project2::iprFile(targetPath, genPath) FOR this»
«ENDDEFINE»


«REM»**********************************************************************«ENDREM»

«DEFINE EntitiesFile FOR Model»
  «FILE "entities.h"»
	#ifndef __ENTITIES_H
	#define __ENTITIES_H

	typedef enum {
		«FOREACH getAllResources().interface AS i-»
			«i.getResource().id()»_«i.name»,
		«ENDFOREACH»
		NUM_PERIPHERALS
	} Peripheral;

	typedef enum {
		«FOREACH getAllFunctionBlocks() AS fb-»
			«fb.id()»_fb,
		«ENDFOREACH»
		NUM_FUNCTION_BLOCKS
	} FunctionBlock;

	typedef enum {
		«FOREACH getAllReachableBehaviours() AS b-»
			BHVR_«b.funcName()»,
		«ENDFOREACH»
		NUM_BEHAVIOURS
	} Behaviour;

	typedef enum {
		«FOREACH getAllFunctionBlocks() AS fb-»
			«FOREACH fb.getReachableBehaviours(this).plan.step.id().toSet() AS sId-»
			«fb.id()»_«sId»,
			«ENDFOREACH»
		«ENDFOREACH»
		NUM_CONDITIONS
	} Condition;

	typedef enum {
		«FOREACH getAllFunctionBlocks() AS fb-»
			«FOREACH fb.getReachableBehaviours(this).plan.getResources(main.config).toSet() AS res-»
				QUEUE_«fb.id()+"_"+res.shortName»,
			«ENDFOREACH-»
			«FOREACH fb.getTaskgroups(this) AS tg-»
				QUEUE_«fb.funcName(tg)»,
			«ENDFOREACH-»
		«ENDFOREACH-»
		«FOREACH getAllResources() AS res-»
			«FOREACH res.getPreconditions(this) AS precon-»
				QUEUE_«precon.getFB().id()+"_"+res.shortName»,
			«ENDFOREACH-»
		«ENDFOREACH-»
		«FOREACH getAllCPUs() AS cpu-»
			QUEUE_System_«cpu.name»_induced,
		«ENDFOREACH-»
		NUM_QUEUES
	} QueueId;

	#endif
  «ENDFILE»
«ENDDEFINE»


«REM»**********************************************************************«ENDREM»

«DEFINE PeripheralsFile FOR Model»
  «FILE "peripherals.h"»
	#ifndef __PERIPHERALS_H
	#define __PERIPHERALS_H

	#include <CLib.h>
	#include "entities.h"

	int getCst(Peripheral peripheral) {
		int cst;
		DELAY(0, unit_us);

		switch (peripheral) {
			«FOREACH getAllResources().interface AS i»
				case «i.getResource().id()»_«i.name»: cst = «i.contextSwitchingTime.round(main.config)»; break;
			«ENDFOREACH»
			default:
				STATE(UnknownPeripheral);
				break;
		}
		return cst;
	}

	int getId(Peripheral peripheral) {
		int id;
		DELAY(0, unit_us);

		switch (peripheral) {
			«FOREACH getAllResources().interface AS i»
				case «i.getResource().id()»_«i.name»: id = «i.inducedCPU.round(main.config)»; break;
			«ENDFOREACH»
			default:
				STATE(UnknownPeripheral);
				break;
		}
		return id;
	}

	int getBw(Peripheral peripheral) {
		int bw;
		DELAY(0, unit_us);

		switch (peripheral) {
			«FOREACH getAllResources().interface AS i»
				case «i.getResource().id()»_«i.name»: bw = «i.bandwidth.round(main.config)»; break;
			«ENDFOREACH»
			default:
				STATE(UnknownPeripheral);
				break;
		}
		return bw;
	}

	int getBs(Peripheral peripheral) {
		int bs;
		DELAY(0, unit_us);

		switch (peripheral) {
			«FOREACH getAllResources().interface AS i»
				case «i.getResource().id()»_«i.name»: bs = «i.getResource().blocksize.round(main.config)»; break;
			«ENDFOREACH»
			default:
				STATE(UnknownPeripheral);
				break;
		}
		return bs;
	}

	#endif

  «ENDFILE»
«ENDDEFINE»


«REM»**********************************************************************«ENDREM»

«DEFINE ModelHeaderFile(String basePath) FOR Model»
  «FILE "model.h"»
	// model-specific settings valid for all generated source-files

	#include <CLib.h>

	// definition of various constants and enums for the model
	#include "entities.h"

	// global definition of INTERLEAVE_TIME
	#define INTERLEAVE_TIME 0

 	// global communication structures, singleton will be placed into shared mem
	typedef struct {
		Event* conditions[NUM_CONDITIONS];
		Queue* queues[NUM_QUEUES];
	} GlobalComm;

	// Job objects encapsulate CPU activities and are put onto the queues during simulation
	typedef struct {
		Semaphore* sema;
		Queue* queue;
		unsigned int kb;
		Peripheral peri;
	} Job;

 	// pointer to GlobalComm struct (which is placed in shared memory)
 	static GlobalComm* gc = (GlobalComm*)0x1000;

  «ENDFILE»
«ENDDEFINE»


«REM»**********************************************************************«ENDREM»

«DEFINE ResourceFile(Set[FunctionBlock] fb, Model model) FOR Resource»
  «FILE shortName+".c"»
	#include "peripherals.h"
	#include "model.h"

	static volatile FunctionBlock last = NUM_FUNCTION_BLOCKS;

	#define «shortName.toUpperCase()»_FOR(name)											\
	void name ## _«shortName»() {											\
		/* wait until GlobalComm struct has been initialized */		\
		DELAY(10, unit_ns);											\
																	\
		Queue* jobs = gc->queues[QUEUE_ ## name ## _«shortName»];	\
		while (1) {													\
			/* fetch new job */										\
			Job job;												\
			receiveQueue(jobs, (char*)&job, sizeof(job));			\
																	\
			/* determine job length */								\
			unsigned int blocksize = getBs(job.peri);				\
			unsigned long long blocks =								\
				job.kb / blocksize;									\
			if (job.kb % blocksize) {								\
				blocks++;											\
			}														\
																	\
			/* calculate times */									\
			unsigned int blockDelay =								\
				(blocksize * 1000ull * 1000ull)						\
				/ (getBw(job.peri) * 1024ull);						\
																	\
			unsigned int inducedDelay =								\
				(blockDelay * getId(job.peri)) / 100ull;			\
																	\
			unsigned int contextSwitchingTime =						\
				(blockDelay * getCst(job.peri)) / 100ull;			\
																	\
			/* do the work blockwise */								\
			while (blocks > 0) {									\
				if (last != name ## _fb) {							\
					DELAY(contextSwitchingTime, unit_us);			\
				}													\
																	\
				sendQueue(job.queue, (const char*)&inducedDelay,	\
						  sizeof(inducedDelay));					\
																	\
				DELAY(blockDelay, unit_us);							\
																	\
				blocks--;											\
				last = name ## _fb;									\
				if (blocks > 0)										\
					schedule();										\
			}														\
																	\
			/* tell cpu job is finished */							\
			releaseSemaphore(job.sema);								\
		}															\
	}

	«FOREACH fb AS fb»
		«IF fb.getReachableBehaviours(model).plan.getResources(model.main.config).contains(this)»
			«shortName.toUpperCase()»_FOR(«fb.id()»)
		«ENDIF»

	«ENDFOREACH»
  «ENDFILE»
«ENDDEFINE»



«REM»**********************************************************************«ENDREM»

«DEFINE SingleCPUFile(String basePath, Model model) FOR CPU»
«FILE name+".c"»
  «LET model.getAllFunctionBlocksOn(this) AS fbs»
  	#include "«basePath»/cpu.h"
  	#include "model.h"

	// model-specific configuration (i.e., variation points, optimization switches...)
  	#include "model_config.h"

	/* **************************************************************************************** */

	DeclareCLibTask(System_«name»,1);
	«FOREACH fbs AS fb-»
		«FOREACH fb.getTaskgroups(model) AS tg-»
		DeclareCLibTask(«fb.funcName(tg)», 1);
		«ENDFOREACH-»
	«ENDFOREACH»

	/* **************************************************************************************** */

	// Initialize the model (one for each cpu)
	// - the first cpu inits all message queues and conditions (in shared mem)
	// - each cpu starts its specific tasks
	«LET model.getAllCPUs().toList().first() == this AS isFirst-»
		void initModel_«name»() {
			«IF isFirst-»
				int i;
				DELAY(0, unit_us);

				// initialize GlobalComm struct (this is done by the first CPU only)
				for (i = 0; i < NUM_CONDITIONS; i++) {
					gc->conditions[i] = newEvent();
					resetEvent(gc->conditions[i]);
				}
				for (i = 0; i < NUM_QUEUES; i++) {
					gc->queues[i] = newQueue();
				}
			«ELSE-»
				// all CPUs except the first one have to wait a little bit
				// until initialization of GlobalComm is done
				DELAY(10, unit_ns);
			«ENDIF»

			// start all tasks for this cpu
			resumeTask(CLibTask(System_«name»,1));
			«FOREACH fbs AS fb-»
				«FOREACH fb.getTaskgroups(model) AS tg-»
				resumeTask(CLibTask(«fb.funcName(tg)»,1));
				«ENDFOREACH-»
			«ENDFOREACH-»

			// send initial triggers for this cpu
			«FOREACH model.getAllExternalTriggers() AS tr-»
				«IF fbs.contains(tr.fb)-»
					sendTrigger(«tr.fb.id()», «tr.trigger.taskgroup», «tr.trigger.id()»);
				«ENDIF-»
			«ENDFOREACH-»
		}
	«ENDLET»

	/* **************************************************************************************** */

	/* include common part for all cpus */
	#include "«basePath»/cpu_common.c"

	/* **************************************************************************************** */

	/* This is the System-Task (one for each cpu).
	 * It's responsible for causing the induced delays resulting
	 * out of the peripheral accesses. */
	void System_«name»() {
		unsigned int loadInUs;
		while (1) {
			«EXPAND ReceiveQueue("loadInUs") FOR "System_"+name+"_induced"-»
			DELAY(loadInUs, unit_us);
		}
	}

	/* **************************************************************************************** */

  	«EXPAND FunctionBlockBehaviours(model) FOREACH fbs»
  «ENDLET»
«ENDFILE»
«ENDDEFINE»


«REM»**********************************************************************«ENDREM»

«DEFINE FunctionBlockBehaviours(Model model) FOR FunctionBlock»
	/* behaviour and taskgroup routines for function block «id()» */
	«EXPAND FunctionBlockBehaviourRoutine(model) FOREACH getReachableBehaviours(model)»
	«EXPAND FunctionBlockTaskgroup(this, model) FOREACH getTaskgroups(model)»
«ENDDEFINE»

«DEFINE FunctionBlockTaskgroup(FunctionBlock fb, Model model) FOR Integer»
	void «fb.funcName(this)»() {
		DELAY(0, unit_us);

		while (1) {
			int msg;
			«EXPAND ReceiveQueue("msg") FOR fb.funcName(this)-»
			switch (msg) {
				«FOREACH fb.getReachableBehaviours(model).select(b|b.taskgroup==this) AS b-»
				case BHVR_«b.funcName()»: {
					«b.funcName()»();
					break;
				}
				«ENDFOREACH-»
			}
		}
	}
«ENDDEFINE»


«DEFINE FunctionBlockBehaviourRoutine(Model model) FOR Behaviour»
	«LET this.getFB().getCPU(model) AS cpu»
		static void «this.funcName()»() {
			DELAY(0, unit_us);
			«FOREACH this.plan.step AS s SEPARATOR "\n"-»
				«EXPAND Precondition(model.main.config) FOREACH s.getPreconditions(model.main.config)»
				«EXPAND GetCondition FOREACH s.getAccessedResources(model.main.config).getPreconditions(model).toSet()-»
				«EXPAND ActionCode(getFB().id(), cpu, model.main.config) FOREACH s.action-»
				setCondition(«getFB().id()», «s.id()»);
			«ENDFOREACH-»

			«FOREACH this.directSuccs(model.main.config) AS succ-»
				sendTrigger(«succ.getFB().id()», «succ.taskgroup», «succ.id()»);
			«ENDFOREACH-»
		}
	«ENDLET»
«ENDDEFINE»


«DEFINE Precondition(FeatureConfig cfg) FOR Precondition-»
	«IF opt»
	// this is a non-technical dependency introduced for optimization purposes
	#ifdef «EXPAND ConfigId(cfg) FOR this-»
	«ENDIF»
	«EXPAND GetCondition FOR ref.bind(cfg).step-»
	«IF opt-»
	#endif
	«ENDIF»
«ENDDEFINE»


«DEFINE GetCondition FOR Step-»
	getCondition(«getFB().id()», «id()»);
«ENDDEFINE»


«DEFINE ConfigId(FeatureConfig cfg) FOR Precondition-»
«LET (Step)this.eContainer AS containingStep-»
OPT_«containingStep.getFB().id()»_«containingStep.id()»_WAITS_FOR_«ref.bind(cfg).step.getFB().id()»_«ref.bind(cfg).step.id()-»
«ENDLET-»
«ENDDEFINE»


«DEFINE ActionCode(String fbId, CPU cpu, FeatureConfig cfg) FOR Action-»
	execute«getResourceIOs(cfg).size»(«(consumedCPU.eval(cfg)*cpuFactor(cpu, cfg)).rounded()», «additionalWaitTime.round(cfg)-», INTERLEAVE_TIME
	«IF getResourceIOs(cfg).size>0-»
		, QUEUE_System_«cpu.name-»_induced
	«ENDIF-»
	«FOREACH getResourceIOs(cfg) AS io-»
		, «io.getInterface().getResource().id()»_«io.getInterface().name-»,
		QUEUE_«fbId»_«io.getInterface().getResource().shortName-»,
		«(io.amount.eval(cfg) * 1024).rounded()-»
	«ENDFOREACH-»
	);
«ENDDEFINE»


«DEFINE ReceiveQueue(String bufferName) FOR String-»
	receiveQueue(gc->queues[QUEUE_«this»], (char*)&«bufferName», sizeof(«bufferName»));
«ENDDEFINE»

